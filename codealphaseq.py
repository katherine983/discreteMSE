# -*- coding: utf-8 -*-
"""
Created on Tue Jun 30 15:25:34 2020

@author: wuest
"""

#This program reads a CASAS file and codes the sensor messages with a numeric code
#and produces a coded list representation of the sensor data


from pointwiseMI import pointwiseMI as PPMI
import pathlib
import re
import pandas as pd


#parse text files from CASAS data downloader
def parse_datadownloader(file_to_open):
    """
    parses text files generated by the CASAS data downloader

    Parameters
    ----------
    file_to_open : PATH OBJECT
        THE PATH OBJECT FOR THE FILE TO BE PARSED.

    Returns
    -------
    List of each event name in order of occurence in the dataset.

    """
    sequence = []
    with open(file_to_open, 'r') as fhand:
        for line in fhand:
            sequence.extend(re.findall('\s([A-Z]\S+)\s+[A-Z]', line))
    return CodedSeq(sequence)
def parse_seq(file_to_open):
    """
    parses a .csv or .txt file containing time stamped smart home sensor events, the default output format of timeinterval.build_features.py

    Parameters
    ----------
    file_to_open : PATH OBJECT
        THE PATH OBJECT FOR THE FILE TO BE PARSED.

    Returns
    -------
    sequence : CODEDSEQ OBJECT
        CodedSeq object of each event name.

    """
    sequence = []
    with open(file_to_open, 'r') as fhand:
        for line in fhand:
            if re.match('^\D+', line):
                continue
            row=line.rstrip().split(',')
            sequence.append(row[3])
    return CodedSeq(sequence)
#parse output from timeinterval.py where no activity events are not labeled yet
def parse_timeint_seq(file_to_open):
    """
    THIS FUNCTION DEPRECATED. TIMEINTERVAL.PY NO LONGER OUTPUTS UNLABELED 'NOACTIVITY' EVENTS.
    
    parses a .csv or .txt file that is output from timeinterval.py. 

    Parameters
    ----------
    file_to_open : PATH OBJECT
        THE PATH OBJECT FOR THE FILE TO BE PARSED.

    Returns
    -------
    CodedSeq object of each event name including 5 'NoActivity' event types in order of occurence in the dataset.

    """
    
    sequence = []
    with open(file_to_open, 'r') as fhand:
        for line in fhand:
            if re.match('^\D+', line):
                continue
            row=line.rstrip().split(',')
            if re.match('[0-9]+[.][0-9]*', row[-1]):
                try:
                    timeint = float(row[-1])
                    if timeint <= 10:
                        continue
                    elif 10<timeint<=60:
                        sequence.append('ActTrans')
                    elif 60<timeint<=300: #1-5 minutes
                        sequence.append('StillAct')
                    elif 300<timeint<=900:  #5-15 minutes
                        sequence.append('NoActShort')
                    elif 900<timeint<=3600:
                        sequence.append('NoActMod')
                    elif 3600<=timeint<14400:
                        sequence.append('NoActLong')
                    elif timeint>=14400:
                        sequence.append('SleepOOH')
                except TypeError:
                    print("Error converting msg to float on line:", line)
            else: 
                sequence.append(row[3])
    return CodedSeq(sequence)

class CodedSeq():
    """
    Creates a numerically coded sequence from an iterable. Class is a list-like object.
    """
    def __init__(self, sequence):
        self.symbols=list(set(sequence))
        self.symbols.sort()
        self.sequence = sequence
        self.code_dict = {name:i for i,name in enumerate(self.symbols, start=1)}
        self.coded_seq = [self.code_dict[x] for x in self.sequence]
    
    def to_DF(self):
        code_df = pd.DataFrame.from_dict(self.code_dict, columns=['code_int'], orient='index')
        return code_df

if __name__ == '__main__':
    import cgr_renyi.usm_make as usm
    import numpy as np
    import matplotlib.pyplot as plt
    #from scipy.stats import gaussian_kde
    
    data_folder = pathlib.Path(r"C:\\Users\\wuest\\Documents\\Dementia Research\\SHdata")
    fname = "tm017_20200622_20200630_allevents.txt"
    file_to_open = data_folder/fname
    sequence = parse_seq(file_to_open)
    #print(sequence.sequence[0:20])
    #print(sequence.coded_seq[0:20])
    print(sequence.code_dict)
    label_dict={v:k for k,v in sequence.code_dict.items()}
    A=list(sequence.code_dict.values())
    coords=usm.cgr2d(sequence.coded_seq, A=A)
    xy=np.asarray(coords.fw)
    #z=gaussian_kde(xy)(xy)
    df=pd.DataFrame(xy, columns=['x', 'y'])
    #df['density']=z
    #df.sort_values('density', axis=0, inplace=True)
    plt.figure(figsize=(10,8), dpi=800)
    plt.hexbin(df.x, df.y, gridsize=300, linewidths=0.01, edgecolors='k', cmap='viridis', mincnt=1)
    #plt.scatter(df.x, df.y, s=2, c=df.density)
    for a, c in coords.coord_dict.items():
        label=label_dict[a]
        txt=1.15*np.asarray(c)-np.array((0.1,0))
        plt.annotate('{}'.format(label), xy=c, xytext=txt, fontsize=5)
    ax=plt.axes()
    ax.set_facecolor('white')
    ax.set_xlim(-1.25,1.25)
    ax.set_ylim(-1.25,1.25)
    plt.show()
    """
    sensor_names=list(set(sequence))
    sensor_names.sort()
    sensor_code = {name:i for i,name in enumerate(sensor_names, start=1)}
    sensor_code_df = pd.DataFrame.from_dict(sensor_code, columns=['code_int'], orient='index')
    
    coded_seq = [sensor_code[x] for x in sequence]
    """
    """
    #%%
    MI_matrix, midict = PPMI(coded_seq.coded_seq)
    
    sensor_names=coded_seq.symbols
    PPMI_Table=pd.DataFrame(MI_matrix, index=sensor_names, columns=sensor_names)
    print(PPMI_Table)
    #%%
    
    
    Row_Min=PPMI_Table.idxmin(axis=1)
    Min_PPMI=PPMI_Table.min(axis=1, numeric_only=True)
    Row_Max=PPMI_Table.idxmax(axis=1)
    Max_PPMI=PPMI_Table.max(axis=1, numeric_only=True)
    extrema = {'Row_Min':Row_Min, 'Min_PPMI':Min_PPMI, 'Row_Max':Row_Max, 'Max_PPMI':Max_PPMI}
    PPMI_extrema=pd.DataFrame.from_dict(extrema)
    PPMI_Table=PPMI_Table.join(PPMI_extrema)
    #PPMI_Table.to_excel('tm017_202006_2230_PPMI.xlsx', index_label='Event_Name')
    #%%
    print(coded_seq)
    """
    